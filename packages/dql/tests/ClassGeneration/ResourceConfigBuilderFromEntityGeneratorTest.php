<?php

declare(strict_types=1);

namespace Tests\ClassGeneration;

use EDT\DqlQuerying\ClassGeneration\AbstractTypeFromInterfaceDetector;
use EDT\DqlQuerying\ClassGeneration\ResourceConfigBuilderFromEntityGenerator;
use EDT\DqlQuerying\Contracts\OrderBySortMethodInterface;
use EDT\JsonApi\ResourceConfig\Builder\MagicResourceConfigBuilder;
use EDT\Parsing\Utilities\Types\ClassOrInterfaceType;
use EDT\Parsing\Utilities\Types\NonClassOrInterfaceType;
use EDT\PathBuilding\DocblockPropertyByTraitEvaluator;
use EDT\PathBuilding\PropertyTag;
use EDT\PathBuilding\TraitEvaluator;
use EDT\Querying\Contracts\FunctionInterface;
use PHPUnit\Framework\TestCase;
use ReflectionClass;

class ResourceConfigBuilderFromEntityGeneratorTest extends TestCase
{
    private const ENTITY_A_CONFIG = '<?php

declare(strict_types=1);

namespace Foobar;

use EDT\JsonApi\PropertyConfig\Builder\AttributeConfigBuilderInterface;
use EDT\JsonApi\PropertyConfig\Builder\ToManyRelationshipConfigBuilderInterface;
use EDT\JsonApi\PropertyConfig\Builder\ToOneRelationshipConfigBuilderInterface;
use EDT\JsonApi\ResourceConfig\Builder\MagicResourceConfigBuilder;
use Tests\ClassGeneration\EntityA;
use Tests\ClassGeneration\EntityB;

/**
 * WARNING: THIS CLASS IS AUTOGENERATED.
 * MANUAL CHANGES WILL BE LOST ON RE-GENERATION.
 *
 * To add additional properties, you may want to
 * create an extending class and add them there.
 *
 * @template-extends MagicResourceConfigBuilder<EntityA>
 *
 * @property-read AttributeConfigBuilderInterface<EntityA> $propertyA {@link EntityA::propertyA}
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyB {@link EntityA::propertyB}
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyC {@link EntityA::propertyC}
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyD {@link EntityA::propertyD}
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyE {@link EntityA::propertyE}
 * @property-read AttributeConfigBuilderInterface<EntityA> $propertyF {@link EntityA::propertyF}
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyG {@link EntityA::propertyG}
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyH {@link EntityA::propertyH}
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyI {@link EntityA::propertyI}
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityA,EntityB> $propertyJ {@link EntityA::propertyJ}
 */
class EntityAConfig extends MagicResourceConfigBuilder
{
}
';
    private const ENTITY_A_WITH_INTERFACE_CONFIG = '<?php

declare(strict_types=1);

namespace Foobar;

use EDT\JsonApi\PropertyConfig\Builder\AttributeConfigBuilderInterface;
use EDT\JsonApi\PropertyConfig\Builder\ToManyRelationshipConfigBuilderInterface;
use EDT\JsonApi\PropertyConfig\Builder\ToOneRelationshipConfigBuilderInterface;
use EDT\JsonApi\ResourceConfig\Builder\MagicResourceConfigBuilder;
use Tests\ClassGeneration\EntityAInterface;
use Tests\ClassGeneration\EntityBInterface;

/**
 * WARNING: THIS CLASS IS AUTOGENERATED.
 * MANUAL CHANGES WILL BE LOST ON RE-GENERATION.
 *
 * To add additional properties, you may want to
 * create an extending class and add them there.
 *
 * @template-extends MagicResourceConfigBuilder<EntityAInterface>
 *
 * @property-read AttributeConfigBuilderInterface<EntityAInterface> $propertyA
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyB
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyC
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyD
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyE
 * @property-read AttributeConfigBuilderInterface<EntityAInterface> $propertyF
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyG
 * @property-read ToManyRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyH
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyI
 * @property-read ToOneRelationshipConfigBuilderInterface<EntityAInterface,EntityBInterface> $propertyJ
 */
class EntityAConfig extends MagicResourceConfigBuilder
{
}
';

    public function testGenerateConfigBuilderClass(): void
    {
        $entityClass = ClassOrInterfaceType::fromFqcn(EntityA::class);
        $parentClass = ClassOrInterfaceType::fromFqcn(MagicResourceConfigBuilder::class, [$entityClass]);

        $traitEvaluator = new DocblockPropertyByTraitEvaluator(
            new TraitEvaluator(),
            [],
            [PropertyTag::PROPERTY_READ]
        );

        $generator = new ResourceConfigBuilderFromEntityGenerator($parentClass, $traitEvaluator);

        $file = $generator->generateConfigBuilderClass(
            $entityClass,
            'EntityAConfig',
            'Foobar',
            true
        );

        self::assertSame(self::ENTITY_A_CONFIG, (string)$file);
    }

    public function testGenerateConfigBuilderClassWithInterfaces(): void
    {
        $entityClass = ClassOrInterfaceType::fromFqcn(EntityA::class);
        $interfaceClass = ClassOrInterfaceType::fromFqcn(EntityAInterface::class);
        $parentClass = ClassOrInterfaceType::fromFqcn(MagicResourceConfigBuilder::class, [$interfaceClass]);

        $traitEvaluator = new DocblockPropertyByTraitEvaluator(
            new TraitEvaluator(),
            [],
            [PropertyTag::PROPERTY_READ]
        );

        $parentDetector = new class() extends AbstractTypeFromInterfaceDetector {
            protected function isCorrectInterface(string $interface, ReflectionClass $class): bool
            {
                return str_ends_with($interface, "{$class->getShortName()}Interface");
            }
        };

        $generator = new ResourceConfigBuilderFromEntityGenerator(
            $parentClass,
            $traitEvaluator,
            $parentDetector,
            $parentDetector
        );

        $file = $generator->generateConfigBuilderClass(
            $entityClass,
            'EntityAConfig',
            'Foobar',
            false
        );

        self::assertSame(self::ENTITY_A_WITH_INTERFACE_CONFIG, (string)$file);
    }
}
