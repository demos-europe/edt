<?php

declare(strict_types=1);

namespace EDT\DqlQuerying\ClassGeneration;

use Doctrine\ORM\Mapping\Column;
use Doctrine\ORM\Mapping\ManyToMany;
use Doctrine\ORM\Mapping\ManyToOne;
use Doctrine\ORM\Mapping\OneToMany;
use Doctrine\ORM\Mapping\OneToOne;
use EDT\Parsing\Utilities\Types\ClassOrInterfaceType;
use EDT\PathBuilding\End;
use EDT\PathBuilding\PropertyAutoPathInterface;
use EDT\PathBuilding\PropertyAutoPathTrait;
use Nette\PhpGenerator\PhpFile;
use ReflectionClass;
use ReflectionProperty;

/**
 * Generates source code for a class implementing {@link PropertyAutoPathInterface}.
 * The generated class corresponds to a Doctrine entity class and will expose all
 * Doctrine properties as path segments.
 *
 * Properties in parents of the given entity class may or may not be supported.
 */
class PathClassFromEntityGenerator
{
    use EntityBasedGeneratorTrait;

    /**
     * Generates a class with methods to start each given path class.
     *
     * @param list<ClassOrInterfaceType> $pathClasses
     * @param non-empty-string $targetName
     * @param non-empty-string $targetNamespace
     * @param callable(ClassOrInterfaceType): non-empty-string $methodNameCallback
     */
    public function generateEntryPointClass(
        array $pathClasses,
        string $targetName,
        string $targetNamespace,
        callable $methodNameCallback
    ): PhpFile {
        $newFile = new PhpFile();
        $newFile->setStrictTypes();

        $namespace = $newFile->addNamespace($targetNamespace);
        $class = $namespace->addClass($targetName);

        $class->addComment('WARNING: THIS CLASS IS AUTOGENERATED.');
        $class->addComment("MANUAL CHANGES WILL BE LOST ON RE-GENERATION.\n");

        // Iterate over the properties of the entity class
        foreach ($pathClasses as $pathClass) {
            $shortClassName = $pathClass->getShortClassName();

            // add use declarations
            array_map([$namespace, 'addUse'], $pathClass->getAllFullyQualifiedNames());

            // add method
            $method = $class->addMethod($methodNameCallback($pathClass));
            $fullTypeString = $pathClass->getFullString(true);
            if ($fullTypeString !== $shortClassName) {
                $method->addComment("@return $fullTypeString");
            }
            $method->setStatic();
            $method->setPublic();
            $method->addBody("return $shortClassName::startPath();");
            $method->setReturnType($pathClass->getFullyQualifiedName());
        }

        return $newFile;
    }
    
    /**
     * Generate a path class from the given base class.
     *
     * Assumes path classes corresponding to the properties in the given entity class exist in the same namespace.
     *
     * @param ReflectionClass<object> $entityClass
     * @param non-empty-string $targetName
     * @param non-empty-string $targetNamespace
     */
    public function generatePathClass(ReflectionClass $entityClass, string $targetName, string $targetNamespace): PhpFile
    {
        $newFile = new PhpFile();
        $newFile->setStrictTypes();

        $namespace = $newFile->addNamespace($targetNamespace);
        $class = $namespace->addClass($targetName);

        $class->addComment('WARNING: THIS CLASS IS AUTOGENERATED.');
        $class->addComment("MANUAL CHANGES WILL BE LOST ON RE-GENERATION.\n");
        $class->addComment('To add additional properties, you may want to');
        $class->addComment("create an extending class and add them there.\n");

        $class->addImplement(PropertyAutoPathInterface::class);
        $namespace->addUse(PropertyAutoPathInterface::class);
        $class->addTrait(PropertyAutoPathTrait::class);
        $namespace->addUse(PropertyAutoPathTrait::class);

        $entityType = ClassOrInterfaceType::fromFqcn($entityClass->getName());
        array_map([$namespace, 'addUse'], $entityType->getAllFullyQualifiedNames());

        $this->processProperties(
            $entityClass->getProperties(),
            function (
                ReflectionProperty $property,
                Column|OneToMany|OneToOne|ManyToOne|ManyToMany $doctrineClass
            ) use ($class, $targetNamespace, $namespace, $entityType): void {
                $propertyType = $this->mapToClass($entityType, $doctrineClass, $targetNamespace, $property);
                $propertyName = $property->getName();

                // add uses
                $namespace->addUse($propertyType);

                // build reference
                $reference = $this->buildReference($entityType, $propertyName);


                $pathNames = explode('\\', $propertyType);
                $propertyTypeString = array_pop($pathNames);

                $class->addComment("@property-read $propertyTypeString \$$propertyName $reference");
            }
        );

        return $newFile;
    }

    /**
     * @param non-empty-string $targetNamespace
     *
     * @return non-empty-string
     */
    protected function mapToClass(ClassOrInterfaceType $entityType, Column|OneToMany|OneToOne|ManyToOne|ManyToMany $annotationOrAttribute, string $targetNamespace, ReflectionProperty $property): string
    {
        if ($annotationOrAttribute instanceof Column) {
            return End::class;
        }

        $targetEntity = $this->getTargetEntityClass($entityType->getFullyQualifiedName(), $property->getName(), $annotationOrAttribute);
        $relationship = ClassOrInterfaceType::fromFqcn($targetEntity);

        return "$targetNamespace\\{$relationship->getShortClassName()}Path";
    }
}
