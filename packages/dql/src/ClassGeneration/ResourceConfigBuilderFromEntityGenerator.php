<?php

declare(strict_types=1);

namespace EDT\DqlQuerying\ClassGeneration;

use Doctrine\ORM\Mapping\Column;
use Doctrine\ORM\Mapping\ManyToMany;
use Doctrine\ORM\Mapping\ManyToOne;
use Doctrine\ORM\Mapping\OneToMany;
use Doctrine\ORM\Mapping\OneToOne;
use EDT\JsonApi\PropertyConfig\Builder\AttributeConfigBuilderInterface;
use EDT\JsonApi\PropertyConfig\Builder\ToManyRelationshipConfigBuilderInterface;
use EDT\JsonApi\PropertyConfig\Builder\ToOneRelationshipConfigBuilderInterface;
use EDT\Parsing\Utilities\ClassOrInterfaceType;
use EDT\Parsing\Utilities\TypeInterface;
use EDT\PathBuilding\DocblockPropertyByTraitEvaluator;
use Nette\PhpGenerator\PhpFile;
use ReflectionClass;
use ReflectionProperty;
use Webmozart\Assert\Assert;
use function array_key_exists;

class ResourceConfigBuilderFromEntityGenerator
{
    use EntityBasedGeneratorTrait;

    /**
     * @var array<non-empty-string, TypeInterface>
     */
    private readonly array $existingProperties;

    public function __construct(
        protected readonly TypeInterface $conditionType,
        protected readonly TypeInterface $sortingType,
        protected readonly ClassOrInterfaceType $parentClass,
        protected readonly DocblockPropertyByTraitEvaluator $traitEvaluator
    ) {
        $this->existingProperties = $this->traitEvaluator
            ->parseProperties($this->parentClass->getFullyQualifiedName(), true);
    }

    /**
     * Generate a config builder class from the given base class.
     *
     * @param non-empty-string $targetName
     * @param non-empty-string $targetNamespace
     */
    public function generateConfigBuilderClass(
        ClassOrInterfaceType $entityType,
        string               $targetName,
        string               $targetNamespace
    ): PhpFile {
        $newFile = new PhpFile();
        $newFile->setStrictTypes();

        $reflectionClass = new ReflectionClass($entityType->getFullyQualifiedName());

        $namespace = $newFile->addNamespace($targetNamespace);
        array_map([$namespace, 'addUse'], $this->parentClass->getAllFullyQualifiedNames());

        $class = $namespace->addClass($targetName);

        $class->addComment('WARNING: THIS CLASS IS AUTOGENERATED.');
        $class->addComment("MANUAL CHANGES WILL BE LOST ON RE-GENERATION.\n");
        $class->addComment('To add additional properties, you may want to');
        $class->addComment("create an extending class and add them there.\n");

        $class->setExtends($this->parentClass->getFullyQualifiedName());
        $class->addComment("@template-extends {$this->parentClass->getFullString(true)}");
        $class->addComment('');

        // skip properties that are already defined in the parent class
        $properties = array_filter(
            $reflectionClass->getProperties(),
            fn (ReflectionProperty $property): bool => !array_key_exists($property->getName(), $this->existingProperties)
        );

        $this->processProperties(
            $properties,
            function (
                ReflectionProperty $property,
                Column|OneToMany|OneToOne|ManyToOne|ManyToMany $doctrinePropertySetting
            ) use ($class, $entityType, $namespace): void {
                $targetType = $this->mapToClass($entityType, $doctrinePropertySetting, $property);
                $propertyName = $property->getName();

                // add uses
                array_map([$namespace, 'addUse'], $targetType->getAllFullyQualifiedNames());

                // build reference
                $referencedClass = $entityType->getShortClassName();
                $reference = "{@link $referencedClass::$propertyName}";

                // add property-read tag
                $shortString = $targetType->getFullString(true);
                $class->addComment("@property-read $shortString \$$propertyName $reference");
            }
        );

        return $newFile;
    }

    protected function mapToClass(TypeInterface $entityClass, Column|OneToMany|OneToOne|ManyToOne|ManyToMany $annotationOrAttribute, ReflectionProperty $property): ClassOrInterfaceType
    {
        if ($annotationOrAttribute instanceof Column) {
            $class = AttributeConfigBuilderInterface::class;

            return ClassOrInterfaceType::fromFqcn($class, [$this->conditionType, $entityClass]);
        }

        $class = $annotationOrAttribute instanceof ManyToMany || $annotationOrAttribute instanceof OneToMany
            ? ToManyRelationshipConfigBuilderInterface::class
            : ToOneRelationshipConfigBuilderInterface::class;

        $targetEntityClass = $annotationOrAttribute->targetEntity;
        Assert::notNull($targetEntityClass);
        if (!interface_exists($targetEntityClass) && !class_exists($targetEntityClass)) {
            throw new \InvalidArgumentException(
                "Doctrine relationship was defined via annotation/attribute, but the type set as target entity (`$targetEntityClass`) could not be found. Make sure it uses the fully qualified name. The problematic relationship is: `{$entityClass->getFullString(false)}::{$property->getName()}`."
            );
        }

        $templateParameters = [
            $this->conditionType,
            $this->sortingType,
            $entityClass,
            // TODO: parse docblock further to detect types with template parameters
            ClassOrInterfaceType::fromFqcn($targetEntityClass)
        ];

        return ClassOrInterfaceType::fromFqcn($class, $templateParameters);
    }
}
